{"version":3,"sources":["App.tsx","Provisioner.ts","GatewayDevice.ts","serviceWorker.js","index.js","WifiConfigurationService.ts","WifiScannerService.ts"],"names":["AppPage","Provisioner","device","this","console","log","initialiseGattServer","initialiseServices","Error","scannerService","init","status","getStatus","error","ssid","password","GatewayDevice","_device","_server","configurationService","gatt","connect","WifiConfigurationService","WifiScannerService","Promise","all","navigator","bluetooth","requestDevice","acceptAllDevices","optionalServices","uuid","App","props","provisioner","state","deviceName","undefined","networkList","page","CONNECT","connected","loading","scanDevice","bind","collectPassword","updatePassword","handleBackButton","setLoading","event","searchDevice","setState","getScanList","SCAN_LIST","networkName","PASSWORD_INPUT","ev","data","value","CONFIGURED","previousPage","className","Icon","name","alt","size","Button","onClick","Segment","inverted","Dimmer","active","Loader","color","Header","Table","Body","map","network","index","Row","key","Cell","Input","placeholder","onChange","configureNetwork","React","Component","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","serviceWorker","ready","then","registration","unregister","WifiCongurationStatus","server","service","getPrimaryService","WifiConfigurationStatusCharacteristic","characteristic","getCharacteristic","addEventListener","readValue","buffer","byteLength","getInt8","ERROR","SAVE","JOIN","writeValue","Buffer","from","WifiScanningStatus","WifiScanningStatusCharacteristic","SCAN"],"mappings":"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","file":"static/js/main.3a44dcf4.chunk.js","sourcesContent":["import React from 'react';\n\nimport { Button, Icon, Dimmer, Loader, Segment, Header, Input, Table, InputOnChangeData } from 'semantic-ui-react'\n\nimport Provisioner from './Provisioner'\n\nimport 'semantic-ui-css/semantic.min.css';\nimport './App.css';\nimport GatewayDevice from './GatewayDevice';\n\nenum AppPage {\n  CONNECT,\n  SCAN_LIST,\n  PASSWORD_INPUT,\n  CONFIGURED\n}\n\ninterface IState {\n  deviceName: string | undefined\n  page: AppPage\n  connected: boolean\n  loading: boolean\n  ssid: string | undefined\n  password: string | undefined\n  networkList: string[]\n  provisioner: Provisioner | undefined\n}\n\nclass App extends React.Component<{}, IState> {\n\n  provisioner: Provisioner | undefined\n\n  constructor(props: {}) {\n    super(props)\n    this.state = {\n      deviceName: undefined,\n      networkList: [],\n      ssid: undefined,\n      page: AppPage.CONNECT,\n      connected: false,\n      password: undefined,\n      provisioner: undefined,\n      loading: false\n    }\n    this.scanDevice = this.scanDevice.bind(this)\n    \n    this.collectPassword = this.collectPassword.bind(this)\n    this.updatePassword = this.updatePassword.bind(this)\n    this.handleBackButton = this.handleBackButton.bind(this)\n    this.setLoading = this.setLoading.bind(this)\n  }\n\n  async scanDevice(event: any) {\n\n    let provisioner\n\n    try {\n      this.setLoading(true)\n    \n      provisioner = new Provisioner(await GatewayDevice.searchDevice())\n      this.setLoading(false)\n    \n      console.log('Provisioner', provisioner)\n      this.setState({\n        provisioner: provisioner\n      })\n      this.setLoading(true)\n    \n      let networkList = await provisioner.getScanList()\n      if(networkList)\n      this.setState({\n        networkList: networkList,\n        page: AppPage.SCAN_LIST\n      })\n      this.setLoading(false)\n    \n      \n    } catch(ex) {\n      console.error('ERROR', ex)\n    }\n    // try {\n    //   device = \n    //   await device.initialiseGattServer()\n    //   await device.initialiseServices()\n    //   device.scannerService?.initialiseCharacteristics()\n    //   console.log('scannerService')\n    //   console.log(await device.scannerService?.status?.getStatus())\n    //   console.log('scannerService')\n    // } catch(ex) {\n    //   console.error(ex)\n    // }\n\n  }\n  async collectPassword(networkName: string) {\n    console.log('collectPassword')\n    this.setLoading(true)\n    \n    this.setState({\n      ssid: networkName,\n      page: AppPage.PASSWORD_INPUT\n    })\n    this.setLoading(false)\n    \n  }\n\n  updatePassword(ev: any, data: InputOnChangeData) {\n    console.log('updatePassword', data.value)\n    this.setState({\n      password: data.value\n    })\n  }\n\n  setLoading(status: boolean) {\n    this.setState({\n      loading: status\n    })\n  }\n\n  async configureNetwork(password: string | undefined) {\n    console.log('configureNetwork')\n    this.setLoading(true)\n    this.setState({\n      password: password,\n      page: AppPage.CONFIGURED\n    })\n    this.setLoading(false)\n    \n  }\n\n  handleBackButton() {\n    const { page } = this.state\n    if(page === AppPage.CONNECT)\n      return\n    let previousPage = page - 1\n    this.setState({\n      page: previousPage\n    })\n  }\n\n  render() {\n\n    const { deviceName, page, loading, networkList, ssid, password } = this.state\n    return <div className=\"App\">\n      { page === AppPage.CONNECT ?\n        <header className=\"App-header\">\n          <Icon name=\"wifi\" className=\"App-logo\" alt=\"logo\" size=\"huge\"></Icon>\n          <p>\n            Pair with a HIFE Hub to get started.\n          </p>\n\n          <Button onClick={this.scanDevice}>\n            Scan\n          </Button>\n        </header> : ''\n      }\n      { page === AppPage.SCAN_LIST ?\n      <Segment inverted className=\"App scan_list\">\n        <Dimmer active={loading}>\n          <Loader>Connecting to {deviceName??\"Smart Hub\"}</Loader>\n        </Dimmer>\n        <Icon name=\"arrow circle left\" onClick={this.handleBackButton} color=\"yellow\" size=\"large\"></Icon>\n        <Header>\n            {deviceName??\"Havells\"}\n        </Header>\n        <Table inverted>\n          <Table.Body>\n          {\n            networkList.map((network, index) => <Table.Row key={index}><Table.Cell onClick={() => {this.collectPassword(network) }}>{network}</Table.Cell></Table.Row>)\n          }\n          </Table.Body>\n        </Table>\n        </Segment>:''\n      }\n      {\n        page === AppPage.PASSWORD_INPUT?\n        <Segment inverted className=\"App password_input\">\n          <Icon name=\"arrow circle left\" onClick={this.handleBackButton} color=\"yellow\"></Icon>\n          <Icon name=\"wifi\" size=\"huge\" color= \"blue\"></Icon>\n          <Header size=\"medium\">{ssid}</Header>\n          <Input placeholder='Password' size=\"large\" onChange={this.updatePassword}/>\n          <Button onClick={() => {this.configureNetwork(password) }}>Connect</Button>\n        </Segment>:''\n      }\n      {\n        page === AppPage.CONFIGURED ? \n        <Segment inverted className=\"App configured\">\n          <Dimmer active={loading}>\n            <Loader>Connecting {deviceName?? \"Smart Hub\"} to {ssid??\"Smart Hub\"}</Loader>\n          </Dimmer>\n\n          <Icon name=\"arrow circle left\" onClick={this.handleBackButton} color=\"yellow\"></Icon>\n          <Icon name=\"check circle\" size=\"massive\" color= \"green\"></Icon>\n          <div>Your Smart Hub has been connected to WiFi successfully</div>\n        </Segment>\n        : ''\n      }\n    </div>\n  }\n}\n\nexport default App;\n","import GatewayDevice from \"./GatewayDevice\";\n\nexport default class Provisioner {\n    \n    private device: GatewayDevice\n    \n    constructor(device: GatewayDevice) {\n        this.device = device\n    }\n\n    async init() {\n        console.log(\"=====\")\n        await this.device.initialiseGattServer()\n        await this.device.initialiseServices()\n        console.log(\"=====\")\n    }\n\n    async getScanList() {\n        try {\n            if(!this.device)\n                throw Error(\"Could not find device\")\n\n            await this.device.initialiseGattServer()\n            await this.device.initialiseServices()\n            await this.device.scannerService?.init()\n            let status = this.device.scannerService?.status?.getStatus()\n            console.log(status)\n        } catch(ex) {\n            console.error(ex)\n        }\n        return [\"Tesesract\", \"Poseidon\"]\n    }\n\n    async setWifiConfig(ssid: String, password: String) {\n        // try {\n        //     this.device.configurationService.init()\n        // } catch(ex) {\n        //     console.error(ex)\n        // }\n    }\n\n}\n","import WifiConfigurationService from './WifiConfigurationService'\nimport WifiScannerService from './WifiScannerService'\n\n\nexport default class GatewayDevice {\n\n    private _device: BluetoothDevice\n    private _server: BluetoothRemoteGATTServer | undefined\n\n    configurationService: WifiConfigurationService | undefined\n    scannerService: WifiScannerService | undefined\n\n    constructor(device: BluetoothDevice) {\n        this._device = device\n    }\n\n    async initialiseGattServer() {\n        return await this._device.gatt?.connect();\n    }\n\n    async initialiseServices() {\n        if(!this._server)\n            return\n        this.configurationService = new WifiConfigurationService(this._server)\n        this.scannerService = new WifiScannerService(this._server)\n\n        console.log('Device Services initing...')\n\n        await Promise.all([\n            this.configurationService.init(),\n            this.scannerService.init()\n        ])\n\n        console.log('Device Services init')\n\n        return\n\n    }\n\n    static async searchDevice(): Promise<GatewayDevice> {\n        return new GatewayDevice(await navigator.bluetooth.requestDevice({\n            acceptAllDevices: true,\n            optionalServices: [0x180D, WifiConfigurationService.uuid, WifiScannerService.uuid]\n        }))\n    }\n\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","\n\n// const UUID = {\n//     WIFI_CONFIGURATION: {\n//       SERVICE: '2b42180d-0000-1000-9900-00805f9b5ab3',\n//       STATUS: '0000180d-0000-1000-9901-00805f9b34fb',\n//       SSID: '0000180d-0000-1000-9902-00805f9b34fb',\n//       PASSWORD: '0000180d-0000-1000-9903-00805f9b34fb',\n//       SECURITY: '0000180d-0000-1000-9904-00805f9b34fb'\n//     }\n// }\n\nexport default class WifiConfigurationService {\n    \n    static uuid: string = '2b42180d-0000-1000-9900-00805f9b5ab3'\n\n    private server: BluetoothRemoteGATTServer\n    service: BluetoothRemoteGATTService | null = null\n\n    constructor(server: BluetoothRemoteGATTServer) {\n        this.server = server\n    }\n\n    async init() {\n        return await this.server.getPrimaryService(WifiConfigurationService.uuid).then(service => this.service = service)\n    }\n\n    initialiseCharacteristics() {\n        if(!this.service) {\n            console.error('No Service found')\n            return\n        }\n        new WifiConfigurationStatusCharacteristic(this.service)\n    }\n\n}\n\nenum WifiCongurationStatus{\n    IDLE,\n    SAVE, \n    SAVING, \n    SAVED, \n    JOIN,\n    JOINING,\n    JOINED,\n    ERROR\n}\n\nexport class WifiConfigurationStatusCharacteristic {\n    static uuid = '0000180d-0000-1000-9901-00805f9b34fb'\n\n    characteristic: BluetoothRemoteGATTCharacteristic | null = null\n\n    constructor(service: BluetoothRemoteGATTService) {\n       service.getCharacteristic(WifiConfigurationStatusCharacteristic.uuid).then(characteristic => { \n           this.characteristic = characteristic\n           this.characteristic.addEventListener(\"characteristicvaluechanged\", (event: Event) => {\n                \n            })\n        })\n       \n    }\n\n    async getStatus() {\n        if(!this.characteristic) {\n            console.error('No Characteristic found')\n            return\n        }\n        let status = await this.characteristic.readValue()\n        if(status.buffer.byteLength < 1 || status.buffer.byteLength > 1 )\n            return WifiCongurationStatus[status.getInt8(0)]\n        return WifiCongurationStatus.ERROR\n    }\n\n    async setStatus(status: WifiCongurationStatus) {\n        if(!this.characteristic) {\n            console.error('No Characteristic found')\n            return\n        }\n        if((status !== WifiCongurationStatus.SAVE) && (status !== WifiCongurationStatus.JOIN))\n            return\n        return await this.characteristic.writeValue(Buffer.from([status]))\n    }\n\n}\n","\nexport default class WifiScannerService {\n    \n    static uuid: string = '2b42180d-0000-1000-7700-00805f9b5ab3'\n\n    private service: BluetoothRemoteGATTService | null = null\n    private server: BluetoothRemoteGATTServer\n    status: WifiScanningStatusCharacteristic | null = null\n\n    constructor(server: BluetoothRemoteGATTServer) {\n        this.server = server\n    }\n\n    async init() {\n        console.log('init')\n        try {\n            this.service = await this.server.getPrimaryService(WifiScannerService.uuid)\n            console.log('WifiScannerService', this.service, 'isAvailable')\n        } catch(ex) {\n            console.error(ex)\n        }\n        return\n    }\n\n    initialiseCharacteristics() {\n        if(!this.service) {\n            console.error('No Service found')\n            return\n        }\n        this.status = new WifiScanningStatusCharacteristic(this.service)\n    }\n\n}\n\nenum WifiScanningStatus{\n    IDLE,\n    SCAN, \n    SCANNING, \n    SCANNED, \n    ERROR\n}\n\nexport class WifiScanningStatusCharacteristic {\n    static uuid = '2b42180d-0000-1000-7701-00805f9b5ab3'\n\n    characteristic: BluetoothRemoteGATTCharacteristic | null = null\n\n    constructor(service: BluetoothRemoteGATTService) {\n       service.getCharacteristic(WifiScanningStatusCharacteristic.uuid).then(characteristic => { \n           this.characteristic = characteristic\n           this.characteristic.addEventListener(\"characteristicvaluechanged\", (event: Event) => {\n                \n            })\n        })\n       \n    }\n\n    async getStatus() {\n        if(!this.characteristic) {\n            console.error('No Characteristic found')\n            return\n        }\n        let status = await this.characteristic.readValue()\n        if(status.buffer.byteLength < 1 || status.buffer.byteLength > 1 )\n            return WifiScanningStatus[status.getInt8(0)]\n        return WifiScanningStatus.ERROR\n    }\n\n    async setStatus(status: WifiScanningStatus) {\n        if(!this.characteristic) {\n            console.error('No Characteristic found')\n            return\n        }\n        if(status !== WifiScanningStatus.SCAN)\n            return\n        return await this.characteristic.writeValue(Buffer.from([status]))\n    }\n\n}\n"],"sourceRoot":""}